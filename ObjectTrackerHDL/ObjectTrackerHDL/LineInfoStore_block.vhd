-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\ObjectTrackerHDL\LineInfoStore_block.vhd
-- Created: 2024-12-03 00:37:47
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LineInfoStore_block
-- Source Path: ObjectTrackerHDL/ObjectTrackerHDL/Preprocess/Edge Detector/LineBuffer/LineInfoStore
-- Hierarchy Level: 4
-- Model version: 3.7
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY LineInfoStore_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        hStartIn                          :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        vEndIn                            :   IN    std_logic;
        validIn                           :   IN    std_logic;
        dumpControl                       :   IN    std_logic;
        preProcess                        :   IN    std_logic;
        PrePadFlag                        :   OUT   std_logic;
        OnLineFlag                        :   OUT   std_logic;
        PostPadFlag                       :   OUT   std_logic;
        DumpingFlag                       :   OUT   std_logic;
        BlankingFlag                      :   OUT   std_logic;
        hStartOut                         :   OUT   std_logic;
        hEndOut                           :   OUT   std_logic;
        vEndOut                           :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END LineInfoStore_block;


ARCHITECTURE rtl OF LineInfoStore_block IS

  -- Signals
  SIGNAL validTemp1                       : std_logic;
  SIGNAL validTemp2                       : std_logic;
  SIGNAL intdelay_reg                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL hStartFirstTap                   : std_logic;
  SIGNAL hStartFinalTap                   : std_logic;
  SIGNAL hEndFirstTap                     : std_logic;
  SIGNAL hEndSecondTap                    : std_logic;
  SIGNAL intdelay_reg_1                   : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL hEndFinalTap                     : std_logic;
  SIGNAL intdelay_reg_2                   : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL intdelay_reg_3                   : std_logic_vector(2 DOWNTO 0);  -- ufix1 [3]
  SIGNAL validFirstTap                    : std_logic;
  SIGNAL validGate1                       : std_logic;
  SIGNAL notPreProcess                    : std_logic;
  SIGNAL validGate2                       : std_logic;
  SIGNAL validGate3                       : std_logic;
  SIGNAL validGate4                       : std_logic;

BEGIN
  validTemp1 <= validIn OR dumpControl;

  validTemp2 <= hEndIn OR validTemp1;

  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validTemp2 = '1' THEN
        intdelay_reg(0) <= hStartIn;
        intdelay_reg(1) <= intdelay_reg(0);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  hStartFirstTap <= intdelay_reg(1);

  intdelay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hStartFinalTap <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validTemp2 = '1' THEN
        hStartFinalTap <= hStartFirstTap;
      END IF;
    END IF;
  END PROCESS intdelay_1_process;


  reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hEndFirstTap <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validTemp2 = '1' THEN
        hEndFirstTap <= hEndIn;
      END IF;
    END IF;
  END PROCESS reg_process;


  intdelay_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hEndSecondTap <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validTemp2 = '1' THEN
        hEndSecondTap <= hEndFirstTap;
      END IF;
    END IF;
  END PROCESS intdelay_2_process;


  intdelay_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validTemp2 = '1' THEN
        intdelay_reg_1(0) <= hEndSecondTap;
        intdelay_reg_1(1) <= intdelay_reg_1(0);
      END IF;
    END IF;
  END PROCESS intdelay_3_process;

  hEndFinalTap <= intdelay_reg_1(1);

  intdelay_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_2 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validTemp2 = '1' THEN
        intdelay_reg_2(0) <= vEndIn;
        intdelay_reg_2(1) <= intdelay_reg_2(0);
      END IF;
    END IF;
  END PROCESS intdelay_4_process;

  vEndOut <= intdelay_reg_2(1);

  intdelay_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_3 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validTemp2 = '1' THEN
        intdelay_reg_3(0) <= validIn;
        intdelay_reg_3(2 DOWNTO 1) <= intdelay_reg_3(1 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS intdelay_5_process;

  validFirstTap <= intdelay_reg_3(2);

  validGate1 <= hStartFirstTap AND validFirstTap;

  notPreProcess <=  NOT preProcess;

  validGate2 <= validFirstTap AND notPreProcess;

  validGate3 <= validGate1 OR validGate2;

  validGate4 <= hStartFinalTap OR validGate3;

  PrePadFlag <= hStartFirstTap;

  OnLineFlag <= hStartFinalTap;

  PostPadFlag <= hEndSecondTap;

  DumpingFlag <= hEndFirstTap;

  BlankingFlag <= hEndFinalTap;

  hStartOut <= hStartFinalTap;

  hEndOut <= hEndSecondTap;

  validOut <= validGate4;

END rtl;

