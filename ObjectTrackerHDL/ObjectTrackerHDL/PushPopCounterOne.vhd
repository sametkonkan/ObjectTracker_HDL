-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\ObjectTrackerHDL\PushPopCounterOne.vhd
-- Created: 2024-12-03 00:37:47
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: PushPopCounterOne
-- Source Path: ObjectTrackerHDL/ObjectTrackerHDL/Preprocess/Edge Detector/LineBuffer/DATA_MEMORY/PushPopCounterOne
-- Hierarchy Level: 5
-- Model version: 3.7
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY PushPopCounterOne IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        hStartIn                          :   IN    std_logic;
        popIn                             :   IN    std_logic;
        popEnable                         :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        wrAddr                            :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
        pushOut                           :   OUT   std_logic;
        rdAddr                            :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
        popOut                            :   OUT   std_logic;
        EndofLine                         :   OUT   std_logic
        );
END PushPopCounterOne;


ARCHITECTURE rtl OF PushPopCounterOne IS

  -- Signals
  SIGNAL writeCount                       : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL intdelay_reg                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL writeStoreEn                     : std_logic;
  SIGNAL writeCountNext                   : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeCountCurrent                : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL readReset                        : std_logic;
  SIGNAL InBetweenEn                      : std_logic;
  SIGNAL ConstantZero                     : std_logic;
  SIGNAL InBetweenRegIn                   : std_logic;
  SIGNAL InBetween                        : std_logic;
  SIGNAL readCountCompare                 : std_logic;
  SIGNAL popTerm2                         : std_logic;
  SIGNAL popContinue                      : std_logic;
  SIGNAL popTerm1                         : std_logic;
  SIGNAL popCounter                       : std_logic;
  SIGNAL readReset_1                      : std_logic;
  SIGNAL readPop                          : std_logic;
  SIGNAL readCount                        : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL popcountless                     : std_logic;
  SIGNAL readReset_2                      : std_logic;
  SIGNAL startOrEnd                       : std_logic;
  SIGNAL constantTwo                      : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL readCountAhead                   : unsigned(10 DOWNTO 0);  -- ufix11

BEGIN
  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  Write_Count_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      writeCount <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF hStartIn = '1' THEN 
          writeCount <= to_unsigned(16#000#, 11);
        ELSIF popIn = '1' THEN 
          writeCount <= writeCount + to_unsigned(16#001#, 11);
        END IF;
      END IF;
    END IF;
  END PROCESS Write_Count_process;


  wrAddr <= std_logic_vector(writeCount);

  pushOut <= popIn;

  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg(0) <= hEndIn;
        intdelay_reg(1) <= intdelay_reg(0);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  writeStoreEn <= intdelay_reg(1);

  reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      writeCountNext <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND writeStoreEn = '1' THEN
        writeCountNext <= writeCount;
      END IF;
    END IF;
  END PROCESS reg_process;


  reg_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      writeCountCurrent <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND hStartIn = '1' THEN
        writeCountCurrent <= writeCountNext;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  readReset <=  NOT hStartIn;

  InBetweenEn <= hStartIn OR hEndIn;

  ConstantZero <= '0';

  
  InBetweenRegIn <= hEndIn WHEN hStartIn = '0' ELSE
      ConstantZero;

  reg_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      InBetween <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND InBetweenEn = '1' THEN
        InBetween <= InBetweenRegIn;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  popTerm2 <= readCountCompare AND InBetween;

  readCountCompare <= popEnable AND popContinue;

  popTerm1 <= popIn AND readCountCompare;

  popCounter <= popTerm1 OR popTerm2;

  readResetREG_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      readPop <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF readReset_1 = '1' THEN
          readPop <= '0';
        ELSIF hStartIn = '1' THEN
          readPop <= hStartIn;
        END IF;
      END IF;
    END IF;
  END PROCESS readResetREG_process;


  
  popContinue <= '1' WHEN readCount < writeCountCurrent ELSE
      '0';

  popcountless <= popCounter AND (popContinue AND readPop);

  
  readReset_2 <= '1' WHEN readCount = writeCountCurrent ELSE
      '0';

  readReset_1 <= popIn AND (readReset_2 AND readReset);

  startOrEnd <= hStartIn OR readReset_1;

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  Read_Count_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      readCount <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF startOrEnd = '1' THEN 
          readCount <= to_unsigned(16#000#, 11);
        ELSIF popcountless = '1' THEN 
          readCount <= readCount + to_unsigned(16#001#, 11);
        END IF;
      END IF;
    END IF;
  END PROCESS Read_Count_process;


  rdAddr <= std_logic_vector(readCount);

  constantTwo <= to_unsigned(16#005#, 11);

  readCountAhead <= readCount + constantTwo;

  
  EndofLine <= '1' WHEN readCountAhead = writeCountCurrent ELSE
      '0';

  popOut <= popCounter;

END rtl;

