-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\ObjectTrackerHDL\Gamma_Corrector_block.vhd
-- Created: 2024-12-03 00:37:46
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Gamma_Corrector_block
-- Source Path: ObjectTrackerHDL/ObjectTrackerHDL/Preprocess/PrevPreprocess/Gamma Corrector
-- Hierarchy Level: 3
-- Model version: 3.7
-- 
-- Gamma Corrector
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY Gamma_Corrector_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        in1_hStart                        :   IN    std_logic;
        in1_hEnd                          :   IN    std_logic;
        in1_vStart                        :   IN    std_logic;
        in1_vEnd                          :   IN    std_logic;
        in1_valid                         :   IN    std_logic;
        out0                              :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        out1_hStart                       :   OUT   std_logic;
        out1_hEnd                         :   OUT   std_logic;
        out1_vStart                       :   OUT   std_logic;
        out1_vEnd                         :   OUT   std_logic;
        out1_valid                        :   OUT   std_logic
        );
END Gamma_Corrector_block;


ARCHITECTURE rtl OF Gamma_Corrector_block IS

  -- Component Declarations
  COMPONENT Lookup_Table_block2
    PORT( in1                             :   IN    std_logic_vector(7 DOWNTO 0);  -- ufix8
          out_rsvd                        :   OUT   std_logic_vector(7 DOWNTO 0)  -- ufix8
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Lookup_Table_block2
    USE ENTITY work.Lookup_Table_block2(rtl);

  -- Signals
  SIGNAL sregout                          : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL sregout_1                        : std_logic;  -- ufix1
  SIGNAL s                                : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL in0_unsigned                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL s_1                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL out_rsvd                         : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL out_unsigned                     : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL s_2                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL s_3                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL pixelOut                         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL hStart_reg                       : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL hStartOut                        : std_logic;
  SIGNAL hEnd_reg                         : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL hEndOut                          : std_logic;
  SIGNAL vStart_reg                       : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL vStartOut                        : std_logic;
  SIGNAL vEnd_reg                         : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL vEndOut                          : std_logic;

BEGIN
  -- Gamma Curve Table
  u_Lookup_Table : Lookup_Table_block2
    PORT MAP( in1 => std_logic_vector(s_1),  -- ufix8
              out_rsvd => out_rsvd  -- ufix8
              );

  -- dataOut maintains zero when validIn is low
  valid_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sregout <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sregout(0) <= sregout(1);
        sregout(1) <= in1_valid;
      END IF;
    END IF;
  END PROCESS valid_process;


  sregout_1 <= sregout(1);

  s <= to_unsigned(16#00#, 8);

  in0_unsigned <= unsigned(in0);

  -- convert dataIn to LUT address
  s_1 <= in0_unsigned;

  out_unsigned <= unsigned(out_rsvd);

  LUTRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      s_2 <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_2 <= out_unsigned;
      END IF;
    END IF;
  END PROCESS LUTRegister_process;


  
  s_3 <= s WHEN sregout_1 = '0' ELSE
      s_2;

  reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      pixelOut <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        pixelOut <= s_3;
      END IF;
    END IF;
  END PROCESS reg_process;


  out0 <= std_logic_vector(pixelOut);

  hStart_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hStart_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hStart_reg(0) <= in1_hStart;
        hStart_reg(1) <= hStart_reg(0);
      END IF;
    END IF;
  END PROCESS hStart_process;

  hStartOut <= hStart_reg(1);

  out1_hStart <= hStartOut;

  hEnd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hEnd_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hEnd_reg(0) <= in1_hEnd;
        hEnd_reg(1) <= hEnd_reg(0);
      END IF;
    END IF;
  END PROCESS hEnd_process;

  hEndOut <= hEnd_reg(1);

  out1_hEnd <= hEndOut;

  vStart_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vStart_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vStart_reg(0) <= in1_vStart;
        vStart_reg(1) <= vStart_reg(0);
      END IF;
    END IF;
  END PROCESS vStart_process;

  vStartOut <= vStart_reg(1);

  out1_vStart <= vStartOut;

  vEnd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vEnd_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vEnd_reg(0) <= in1_vEnd;
        vEnd_reg(1) <= vEnd_reg(0);
      END IF;
    END IF;
  END PROCESS vEnd_process;

  vEndOut <= vEnd_reg(1);

  out1_vEnd <= vEndOut;

  out1_valid <= sregout(0);

END rtl;

