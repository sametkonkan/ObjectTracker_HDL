-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\ObjectTrackerHDL\DATA_MEMORY.vhd
-- Created: 2024-12-03 00:37:47
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DATA_MEMORY
-- Source Path: ObjectTrackerHDL/ObjectTrackerHDL/Preprocess/Edge Detector/LineBuffer/DATA_MEMORY
-- Hierarchy Level: 4
-- Model version: 3.7
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ObjectTrackerHDL_pkg.ALL;

ENTITY DATA_MEMORY IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        Unloading                         :   IN    std_logic;
        pixelIn                           :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        hStartIn                          :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        validIn                           :   IN    std_logic;
        popEn                             :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        dataVectorOut                     :   OUT   vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
        popOut                            :   OUT   std_logic;
        AllAtEnd                          :   OUT   std_logic
        );
END DATA_MEMORY;


ARCHITECTURE rtl OF DATA_MEMORY IS

  -- Component Declarations
  COMPONENT PushPopCounterOne
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          hStartIn                        :   IN    std_logic;
          popIn                           :   IN    std_logic;
          popEnable                       :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          wrAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          pushOut                         :   OUT   std_logic;
          rdAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          popOut                          :   OUT   std_logic;
          EndofLine                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT SimpleDualPortRAM_generic_block
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT PushPopCounter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          hStartIn                        :   IN    std_logic;
          popIn                           :   IN    std_logic;
          popEnable                       :   IN    std_logic;
          hEndIn                          :   IN    std_logic;
          writeCountPrev                  :   IN    std_logic_vector(10 DOWNTO 0);  -- ufix11
          wrAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          pushOut                         :   OUT   std_logic;
          rdAddr                          :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
          EndofLine                       :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : PushPopCounterOne
    USE ENTITY work.PushPopCounterOne(rtl);

  FOR ALL : SimpleDualPortRAM_generic_block
    USE ENTITY work.SimpleDualPortRAM_generic_block(rtl);

  FOR ALL : PushPopCounter
    USE ENTITY work.PushPopCounter(rtl);

  -- Signals
  SIGNAL pixelIn_unsigned                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL intdelay_reg                     : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL pixelColumn_0                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL validREG                         : std_logic;
  SIGNAL unloadPop                        : std_logic;
  SIGNAL hEndREG                          : std_logic;
  SIGNAL hEndREGT                         : std_logic;
  SIGNAL unloadPopT                       : std_logic;
  SIGNAL validPop                         : std_logic;
  SIGNAL popEn_unsigned                   : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL PopEnSL                          : std_logic;
  SIGNAL writeAddr1                       : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL pushFIFO2                        : std_logic;
  SIGNAL readAddr2                        : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL popFIFO_2                        : std_logic;
  SIGNAL EndofLine1                       : std_logic;
  SIGNAL writeAddr1_unsigned              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeAddrREG1                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL pushOutREG1                      : std_logic;
  SIGNAL pixelColumn1                     : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL PopEnSL_1                        : std_logic;
  SIGNAL writeAddr2                       : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL pushFIFO3                        : std_logic;
  SIGNAL readAddr3                        : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL EndofLine2                       : std_logic;
  SIGNAL writeAddr2_unsigned              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL writeAddrREG2                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL pushOutREG2                      : std_logic;
  SIGNAL pixelColumn2                     : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL dataVecInt                       : vector_of_unsigned8(0 TO 2);  -- uint8 [3]

BEGIN
  u_PushPopCounterOne : PushPopCounterOne
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              hStartIn => hStartIn,
              popIn => validPop,
              popEnable => PopEnSL,
              hEndIn => hEndREG,
              wrAddr => writeAddr1,  -- ufix11
              pushOut => pushFIFO2,
              rdAddr => readAddr2,  -- ufix11
              popOut => popFIFO_2,
              EndofLine => EndofLine1
              );

  u_SimpleDualPortRAM_Generic1_generic : SimpleDualPortRAM_generic_block
    GENERIC MAP( AddrWidth => 11,
                 DataWidth => 8
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(pixelColumn_0),
              wr_addr => std_logic_vector(writeAddrREG1),
              wr_en => pushOutREG1,
              rd_addr => readAddr2,
              dout => pixelColumn1
              );

  u_PushPopCounter2 : PushPopCounter
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              hStartIn => hStartIn,
              popIn => validPop,
              popEnable => PopEnSL_1,
              hEndIn => hEndREG,
              writeCountPrev => writeAddr1,  -- ufix11
              wrAddr => writeAddr2,  -- ufix11
              pushOut => pushFIFO3,
              rdAddr => readAddr3,  -- ufix11
              EndofLine => EndofLine2
              );

  u_SimpleDualPortRAM_Generic2 : SimpleDualPortRAM_generic_block
    GENERIC MAP( AddrWidth => 11,
                 DataWidth => 8
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => pixelColumn1,
              wr_addr => std_logic_vector(writeAddrREG2),
              wr_en => pushOutREG2,
              rd_addr => readAddr3,
              dout => pixelColumn2
              );

  pixelIn_unsigned <= unsigned(pixelIn);

  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg(0) <= pixelIn_unsigned;
        intdelay_reg(1 TO 3) <= intdelay_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  pixelColumn_0 <= intdelay_reg(3);

  reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validREG <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validREG <= validIn;
      END IF;
    END IF;
  END PROCESS reg_process;


  reg_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      unloadPop <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        unloadPop <= validREG;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  reg_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hEndREG <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hEndREG <= hEndIn;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  reg_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hEndREGT <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hEndREGT <= hEndREG;
      END IF;
    END IF;
  END PROCESS reg_3_process;


  unloadPopT <= hEndREGT AND (unloadPop AND Unloading);

  validPop <= validREG OR unloadPopT;

  popEn_unsigned <= unsigned(popEn);

  PopEnSL <= popEn_unsigned(0);

  writeAddr1_unsigned <= unsigned(writeAddr1);

  reg_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      writeAddrREG1 <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        writeAddrREG1 <= writeAddr1_unsigned;
      END IF;
    END IF;
  END PROCESS reg_4_process;


  reg_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      pushOutREG1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        pushOutREG1 <= pushFIFO2;
      END IF;
    END IF;
  END PROCESS reg_5_process;


  PopEnSL_1 <= popEn_unsigned(0);

  writeAddr2_unsigned <= unsigned(writeAddr2);

  reg_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      writeAddrREG2 <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        writeAddrREG2 <= writeAddr2_unsigned;
      END IF;
    END IF;
  END PROCESS reg_6_process;


  reg_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      pushOutREG2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        pushOutREG2 <= pushFIFO3;
      END IF;
    END IF;
  END PROCESS reg_7_process;


  dataVecInt(0) <= pixelColumn_0;
  dataVecInt(1) <= unsigned(pixelColumn1);
  dataVecInt(2) <= unsigned(pixelColumn2);

  outputgen: FOR k IN 0 TO 2 GENERATE
    dataVectorOut(k) <= std_logic_vector(dataVecInt(k));
  END GENERATE;

  reg_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      popOut <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        popOut <= popFIFO_2;
      END IF;
    END IF;
  END PROCESS reg_8_process;


  AllAtEnd <= EndofLine1 AND EndofLine2;

END rtl;

