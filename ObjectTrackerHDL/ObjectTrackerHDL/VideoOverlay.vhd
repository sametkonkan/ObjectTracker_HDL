-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\ObjectTrackerHDL\VideoOverlay.vhd
-- Created: 2024-12-03 00:37:45
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: VideoOverlay
-- Source Path: ObjectTrackerHDL/ObjectTrackerHDL/Overlay/VideoOverlay
-- Hierarchy Level: 2
-- Model version: 3.7
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ObjectTrackerHDL_pkg.ALL;

ENTITY VideoOverlay IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        pixelIn                           :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        ctrlIn_hStart                     :   IN    std_logic;
        ctrlIn_hEnd                       :   IN    std_logic;
        ctrlIn_vStart                     :   IN    std_logic;
        ctrlIn_vEnd                       :   IN    std_logic;
        ctrlIn_valid                      :   IN    std_logic;
        Position                          :   IN    vector_of_std_logic_vector16(0 TO 3);  -- uint16 [4]
        pixelOut                          :   OUT   vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
        ctrlOut_hStart                    :   OUT   std_logic;
        ctrlOut_hEnd                      :   OUT   std_logic;
        ctrlOut_vStart                    :   OUT   std_logic;
        ctrlOut_vEnd                      :   OUT   std_logic;
        ctrlOut_valid                     :   OUT   std_logic
        );
END VideoOverlay;


ARCHITECTURE rtl OF VideoOverlay IS

  -- Component Declarations
  COMPONENT MATLAB_Function
    PORT( position                        :   IN    vector_of_std_logic_vector16(0 TO 3);  -- uint16 [4]
          rowCount                        :   IN    std_logic_vector(31 DOWNTO 0);  -- int32
          colCount                        :   IN    std_logic_vector(31 DOWNTO 0);  -- int32
          colorValue                      :   IN    vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
          lineWidth                       :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          Color                           :   OUT   vector_of_std_logic_vector8(0 TO 2);  -- uint8 [3]
          AddShape                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Divide
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dividend_in                     :   IN    vector_of_std_logic_vector18(0 TO 2);  -- sfix18 [3]
          divisor_in                      :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          quotient                        :   OUT   vector_of_std_logic_vector18(0 TO 2)  -- sfix18 [3]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : MATLAB_Function
    USE ENTITY work.MATLAB_Function(rtl);

  FOR ALL : Divide
    USE ENTITY work.Divide(rtl);

  -- Signals
  SIGNAL vStart                           : std_logic;
  SIGNAL hStart                           : std_logic;
  SIGNAL count_step                       : signed(31 DOWNTO 0);  -- int32
  SIGNAL count_reset                      : signed(31 DOWNTO 0);  -- int32
  SIGNAL HDL_Counter_out1                 : signed(31 DOWNTO 0);  -- int32
  SIGNAL count                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL count_1                          : signed(31 DOWNTO 0);  -- int32
  SIGNAL count_2                          : signed(31 DOWNTO 0);  -- int32
  SIGNAL valid                            : std_logic;
  SIGNAL count_step_1                     : signed(31 DOWNTO 0);  -- int32
  SIGNAL count_reset_1                    : signed(31 DOWNTO 0);  -- int32
  SIGNAL HDL_Counter1_out1                : signed(31 DOWNTO 0);  -- int32
  SIGNAL count_3                          : signed(31 DOWNTO 0);  -- int32
  SIGNAL count_4                          : signed(31 DOWNTO 0);  -- int32
  SIGNAL count_5                          : signed(31 DOWNTO 0);  -- int32
  SIGNAL Constant4_out1                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Constant5_out1                   : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Constant6_out1                   : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Constant7_out1                   : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Constant8_out1                   : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Constant9_out1                   : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Multiport_Switch_out1            : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Multiport_Switch_out1_1          : vector_of_std_logic_vector8(0 TO 2);  -- ufix8 [3]
  SIGNAL Constant1_out1                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Color                            : vector_of_std_logic_vector8(0 TO 2);  -- ufix8 [3]
  SIGNAL AddShape                         : std_logic;
  SIGNAL pixelIn_unsigned                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL HwModeRegister_reg               : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL pixelIn_1                        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Constant3_out1                   : vector_of_signed9(0 TO 2);  -- sfix9 [3]
  SIGNAL Constant3_out1_1                 : vector_of_signed9(0 TO 2);  -- sfix9 [3]
  SIGNAL Constant2_out1                   : vector_of_signed8(0 TO 2);  -- int8 [3]
  SIGNAL Constant2_out1_1                 : vector_of_signed8(0 TO 2);  -- int8 [3]
  SIGNAL mulOutput                        : vector_of_signed17(0 TO 2);  -- sfix17 [3]
  SIGNAL mulOutput_1                      : vector_of_signed17(0 TO 2);  -- sfix17 [3]
  SIGNAL Multiply_Add_add_u               : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL Multiply_Add_out1                : vector_of_signed19(0 TO 2);  -- sfix19 [3]
  SIGNAL Multiply_Add_out1_1              : vector_of_signed19(0 TO 2);  -- sfix19 [3]
  SIGNAL Multiply_Add_out1_2              : vector_of_signed18(0 TO 2);  -- sfix18 [3]
  SIGNAL Multiply_Add_out1_3              : vector_of_std_logic_vector18(0 TO 2);  -- ufix18 [3]
  SIGNAL Constant10_out1                  : signed(7 DOWNTO 0);  -- int8
  SIGNAL delayMatch1_reg                  : std_logic_vector(24 DOWNTO 0);  -- ufix1 [25]
  SIGNAL AddShape_1                       : std_logic;
  SIGNAL Divide_out1                      : vector_of_std_logic_vector18(0 TO 2);  -- ufix18 [3]
  SIGNAL Divide_out1_signed               : vector_of_signed18(0 TO 2);  -- sfix18 [3]
  SIGNAL Data_Type_Conversion_out1        : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Color_unsigned                   : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL delayMatch_reg                   : vector_of_unsigned8(0 TO 74);  -- ufix8 [75]
  SIGNAL Color_1                          : vector_of_unsigned8(0 TO 2);  -- uint8 [3]
  SIGNAL Switch_out1                      : vector_of_unsigned8(0 TO 2);  -- uint8 [3]

  ATTRIBUTE use_dsp : string;

  ATTRIBUTE use_dsp OF mulOutput : SIGNAL IS "yes";

BEGIN
  -- Pixel Alpha blending

  u_MATLAB_Function : MATLAB_Function
    PORT MAP( position => Position,  -- uint16 [4]
              rowCount => std_logic_vector(HDL_Counter_out1),  -- int32
              colCount => std_logic_vector(HDL_Counter1_out1),  -- int32
              colorValue => Multiport_Switch_out1_1,  -- uint8 [3]
              lineWidth => std_logic_vector(Constant1_out1),  -- uint8
              Color => Color,  -- uint8 [3]
              AddShape => AddShape
              );

  u_Divide : Divide
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dividend_in => Multiply_Add_out1_3,  -- sfix18 [3]
              divisor_in => std_logic_vector(Constant10_out1),  -- int8
              quotient => Divide_out1  -- sfix18 [3]
              );

  vStart <= ctrlIn_vStart;

  hStart <= ctrlIn_hStart;

  -- Free running, Signed Counter
  --  initial value   = 0
  --  step value      = 1
  count_step <= to_signed(1, 32);

  count_reset <= to_signed(0, 32);

  count <= HDL_Counter_out1 + count_step;

  
  count_1 <= HDL_Counter_out1 WHEN hStart = '0' ELSE
      count;

  
  count_2 <= count_1 WHEN vStart = '0' ELSE
      count_reset;

  HDL_Counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter_out1 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HDL_Counter_out1 <= count_2;
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  valid <= ctrlIn_valid;

  -- Free running, Signed Counter
  --  initial value   = 0
  --  step value      = 1
  count_step_1 <= to_signed(1, 32);

  count_reset_1 <= to_signed(0, 32);

  count_3 <= HDL_Counter1_out1 + count_step_1;

  
  count_4 <= HDL_Counter1_out1 WHEN valid = '0' ELSE
      count_3;

  
  count_5 <= count_4 WHEN hStart = '0' ELSE
      count_reset_1;

  HDL_Counter1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter1_out1 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HDL_Counter1_out1 <= count_5;
      END IF;
    END IF;
  END PROCESS HDL_Counter1_process;


  Constant4_out1 <= to_unsigned(16#03#, 8);

  Constant5_out1(0) <= to_unsigned(16#FF#, 8);
  Constant5_out1(1) <= to_unsigned(16#00#, 8);
  Constant5_out1(2) <= to_unsigned(16#00#, 8);

  Constant6_out1(0) <= to_unsigned(16#00#, 8);
  Constant6_out1(1) <= to_unsigned(16#FF#, 8);
  Constant6_out1(2) <= to_unsigned(16#00#, 8);

  Constant7_out1(0) <= to_unsigned(16#00#, 8);
  Constant7_out1(1) <= to_unsigned(16#00#, 8);
  Constant7_out1(2) <= to_unsigned(16#FF#, 8);

  Constant8_out1(0) <= to_unsigned(16#00#, 8);
  Constant8_out1(1) <= to_unsigned(16#FF#, 8);
  Constant8_out1(2) <= to_unsigned(16#FF#, 8);

  Constant9_out1(0) <= to_unsigned(16#FF#, 8);
  Constant9_out1(1) <= to_unsigned(16#FF#, 8);
  Constant9_out1(2) <= to_unsigned(16#00#, 8);

  Multiport_Switch_output : PROCESS (Constant4_out1, Constant5_out1, Constant6_out1, Constant7_out1, Constant8_out1,
       Constant9_out1)
  BEGIN
    IF Constant4_out1 = to_unsigned(16#01#, 8) THEN 
      Multiport_Switch_out1 <= Constant5_out1;
    ELSIF Constant4_out1 = to_unsigned(16#02#, 8) THEN 
      Multiport_Switch_out1 <= Constant6_out1;
    ELSIF Constant4_out1 = to_unsigned(16#03#, 8) THEN 
      Multiport_Switch_out1 <= Constant7_out1;
    ELSIF Constant4_out1 = to_unsigned(16#04#, 8) THEN 
      Multiport_Switch_out1 <= Constant8_out1;
    ELSE 
      Multiport_Switch_out1 <= Constant9_out1;
    END IF;
  END PROCESS Multiport_Switch_output;


  outputgen4: FOR k IN 0 TO 2 GENERATE
    Multiport_Switch_out1_1(k) <= std_logic_vector(Multiport_Switch_out1(k));
  END GENERATE;

  Constant1_out1 <= to_unsigned(16#03#, 8);

  pixelIn_unsigned <= unsigned(pixelIn);

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HwModeRegister_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HwModeRegister_reg(0) <= pixelIn_unsigned;
        HwModeRegister_reg(1) <= HwModeRegister_reg(0);
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;

  pixelIn_1 <= HwModeRegister_reg(1);

  Constant3_out1 <= (OTHERS => to_signed(-16#0FF#, 9));

  HwModeRegister_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant3_out1_1 <= (OTHERS => to_signed(16#000#, 9));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant3_out1_1 <= Constant3_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister_1_process;


  Constant2_out1 <= (OTHERS => to_signed(16#00#, 8));

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant2_out1_1 <= (OTHERS => to_signed(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant2_out1_1 <= Constant2_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;



  mulOutput_gen: FOR t_0 IN 0 TO 2 GENERATE
    mulOutput(t_0) <= Constant3_out1_1(t_0) * Constant2_out1_1(t_0);
  END GENERATE mulOutput_gen;


  HwModeRegister_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulOutput_1 <= (OTHERS => to_signed(16#00000#, 17));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        mulOutput_1 <= mulOutput;
      END IF;
    END IF;
  END PROCESS HwModeRegister_2_process;


  Multiply_Add_add_u <= signed(resize(pixelIn_1, 18));

  Multiply_Add_out1_gen: FOR t_01 IN 0 TO 2 GENERATE
    Multiply_Add_out1(t_01) <= resize(Multiply_Add_add_u + resize(mulOutput_1(t_01), 18), 19);
  END GENERATE Multiply_Add_out1_gen;


  HwModeRegister_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Multiply_Add_out1_1 <= (OTHERS => to_signed(16#00000#, 19));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Multiply_Add_out1_1 <= Multiply_Add_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister_3_process;



  Multiply_Add_out1_2_gen: FOR ii IN 0 TO 2 GENERATE
    Multiply_Add_out1_2(ii) <= Multiply_Add_out1_1(ii)(17 DOWNTO 0);
  END GENERATE Multiply_Add_out1_2_gen;


  outputgen3: FOR k IN 0 TO 2 GENERATE
    Multiply_Add_out1_3(k) <= std_logic_vector(Multiply_Add_out1_2(k));
  END GENERATE;

  Constant10_out1 <= to_signed(16#01#, 8);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch1_reg(0) <= AddShape;
        delayMatch1_reg(24 DOWNTO 1) <= delayMatch1_reg(23 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  AddShape_1 <= delayMatch1_reg(24);

  outputgen2: FOR k IN 0 TO 2 GENERATE
    Divide_out1_signed(k) <= signed(Divide_out1(k));
  END GENERATE;


  Data_Type_Conversion_out1_gen: FOR ii1 IN 0 TO 2 GENERATE
    Data_Type_Conversion_out1(ii1) <= unsigned(Divide_out1_signed(ii1)(7 DOWNTO 0));
  END GENERATE Data_Type_Conversion_out1_gen;


  outputgen1: FOR k IN 0 TO 2 GENERATE
    Color_unsigned(k) <= unsigned(Color(k));
  END GENERATE;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0 TO 2) <= Color_unsigned(0 TO 2);
        delayMatch_reg(3 TO 74) <= delayMatch_reg(0 TO 71);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Color_1(0 TO 2) <= delayMatch_reg(72 TO 74);

  
  Switch_out1 <= Data_Type_Conversion_out1 WHEN AddShape_1 = '0' ELSE
      Color_1;

  outputgen: FOR k IN 0 TO 2 GENERATE
    pixelOut(k) <= std_logic_vector(Switch_out1(k));
  END GENERATE;

  ctrlOut_hStart <= ctrlIn_hStart;

  ctrlOut_hEnd <= ctrlIn_hEnd;

  ctrlOut_vStart <= ctrlIn_vStart;

  ctrlOut_vEnd <= ctrlIn_vEnd;

  ctrlOut_valid <= ctrlIn_valid;

END rtl;

