-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\ObjectTrackerHDL\Normalization.vhd
-- Created: 2024-12-03 00:37:46
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Normalization
-- Source Path: ObjectTrackerHDL/ObjectTrackerHDL/Preprocess/CurrPreprocess/Image Statistics/calcMean/Normalization
-- Hierarchy Level: 5
-- Model version: 3.7
-- 
-- Time Division Multiplexed Normalization of lvlOne, lvlTwo, lvlThree, lvlFour Accumulation
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ObjectTrackerHDL_pkg.ALL;

ENTITY Normalization IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        lvlOneCount                       :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
        lvlTwoCount                       :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
        lvlThreeCount                     :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
        lvlFourCount                      :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
        SEL                               :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        lvlOneAcc                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En18
        lvlTwoAcc                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En18
        lvlThreeAcc                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En18
        lvlFourAcc                        :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En18
        normFlag                          :   IN    std_logic;
        Normalized                        :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En24
        );
END Normalization;


ARCHITECTURE rtl OF Normalization IS

  -- Component Declarations
  COMPONENT Lookup_Table_block
    PORT( in1                             :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
          out_rsvd                        :   OUT   std_logic_vector(17 DOWNTO 0)  -- ufix18_En17
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Lookup_Table_block
    USE ENTITY work.Lookup_Table_block(rtl);

  -- Signals
  SIGNAL SEL_unsigned                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL s                                : std_logic;
  SIGNAL s_1                              : std_logic;
  SIGNAL lvlOneCount_unsigned             : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlOneCountD                     : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL LUTDepthforMulPix                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlOneChange                     : std_logic;
  SIGNAL LUTDepth                         : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlOneCountDMUXOut               : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlTwoCount_unsigned             : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlTwoCountD                     : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlThreeCount_unsigned           : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlThreeCountD                   : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlFourCount_unsigned            : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL lvlFourCountD                    : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL countMUXout                      : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL reciprocal                       : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL reciprocal_unsigned              : unsigned(17 DOWNTO 0);  -- ufix18_En17
  SIGNAL recipPipeline_reg                : vector_of_unsigned18(0 TO 1);  -- ufix18 [2]
  SIGNAL reciprocalPiped                  : unsigned(17 DOWNTO 0);  -- ufix18_En17
  SIGNAL intdelay_reg                     : std_logic_vector(1 DOWNTO 0);  -- ufix1 [2]
  SIGNAL s_2                              : std_logic;
  SIGNAL lvlOneAcc_unsigned               : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL lvlOneAccD                       : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL lvlOneAccIn                      : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL lvlTwoAcc_unsigned               : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL lvlThreeAcc_unsigned             : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL lvlFourAcc_unsigned              : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL accMUXout                        : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL intdelay_reg_1                   : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL pipeAccMUXOut                    : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL multiplier_mul_temp              : unsigned(49 DOWNTO 0);  -- ufix50_En35
  SIGNAL recipMultOut                     : unsigned(31 DOWNTO 0);  -- ufix32_En24
  SIGNAL outputPipeline_reg               : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL Normalized_tmp                   : unsigned(31 DOWNTO 0);  -- ufix32_En24

BEGIN
  -- [64x1] LUT of Reciprocal Values
  u_Lookup_Table : Lookup_Table_block
    PORT MAP( in1 => std_logic_vector(countMUXout),  -- ufix6
              out_rsvd => reciprocal  -- ufix18_En17
              );

  SEL_unsigned <= unsigned(SEL);

  s <=  NOT normFlag;

  reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      s_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        s_1 <= s;
      END IF;
    END IF;
  END PROCESS reg_process;


  lvlOneCount_unsigned <= unsigned(lvlOneCount);

  -- Delay Balancing on Count Input
  reg_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      lvlOneCountD <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND s_1 = '1' THEN
        lvlOneCountD <= lvlOneCount_unsigned;
      END IF;
    END IF;
  END PROCESS reg_1_process;


  LUTDepthforMulPix <= to_unsigned(16#3F#, 6);

  -- Reset at 64 Pixels Accumulated
  
  lvlOneChange <= '1' WHEN lvlOneCountD = LUTDepthforMulPix ELSE
      '0';

  LUTDepth <= to_unsigned(16#3F#, 6);

  -- Reset lvlOne Accumulator REG to Current Input
  
  lvlOneCountDMUXOut <= lvlOneCountD WHEN lvlOneChange = '0' ELSE
      LUTDepth;

  lvlTwoCount_unsigned <= unsigned(lvlTwoCount);

  reg_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      lvlTwoCountD <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        lvlTwoCountD <= lvlTwoCount_unsigned;
      END IF;
    END IF;
  END PROCESS reg_2_process;


  lvlThreeCount_unsigned <= unsigned(lvlThreeCount);

  reg_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      lvlThreeCountD <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        lvlThreeCountD <= lvlThreeCount_unsigned;
      END IF;
    END IF;
  END PROCESS reg_3_process;


  lvlFourCount_unsigned <= unsigned(lvlFourCount);

  reg_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      lvlFourCountD <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        lvlFourCountD <= lvlFourCount_unsigned;
      END IF;
    END IF;
  END PROCESS reg_4_process;


  -- TDM Counter Input
  
  countMUXout <= lvlOneCountDMUXOut WHEN SEL_unsigned = to_unsigned(16#0#, 2) ELSE
      lvlTwoCountD WHEN SEL_unsigned = to_unsigned(16#1#, 2) ELSE
      lvlThreeCountD WHEN SEL_unsigned = to_unsigned(16#2#, 2) ELSE
      lvlFourCountD;

  reciprocal_unsigned <= unsigned(reciprocal);

  -- Pipeline Reciprocal Input
  recipPipeline_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      recipPipeline_reg <= (OTHERS => to_unsigned(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        recipPipeline_reg(0) <= reciprocal_unsigned;
        recipPipeline_reg(1) <= recipPipeline_reg(0);
      END IF;
    END IF;
  END PROCESS recipPipeline_process;

  reciprocalPiped <= recipPipeline_reg(1);

  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg(0) <= s;
        intdelay_reg(1) <= intdelay_reg(0);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  s_2 <= intdelay_reg(1);

  lvlOneAcc_unsigned <= unsigned(lvlOneAcc);

  reg_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      lvlOneAccD <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND s_2 = '1' THEN
        lvlOneAccD <= lvlOneAcc_unsigned;
      END IF;
    END IF;
  END PROCESS reg_5_process;


  
  lvlOneAccIn <= lvlOneAccD WHEN s_2 = '0' ELSE
      lvlOneAcc_unsigned;

  lvlTwoAcc_unsigned <= unsigned(lvlTwoAcc);

  lvlThreeAcc_unsigned <= unsigned(lvlThreeAcc);

  lvlFourAcc_unsigned <= unsigned(lvlFourAcc);

  -- TDM Accumulator Input
  
  accMUXout <= lvlOneAccIn WHEN SEL_unsigned = to_unsigned(16#0#, 2) ELSE
      lvlTwoAcc_unsigned WHEN SEL_unsigned = to_unsigned(16#1#, 2) ELSE
      lvlThreeAcc_unsigned WHEN SEL_unsigned = to_unsigned(16#2#, 2) ELSE
      lvlFourAcc_unsigned;

  -- Pipeline Accumulator Input
  intdelay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg_1 <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg_1(0) <= accMUXout;
        intdelay_reg_1(1) <= intdelay_reg_1(0);
      END IF;
    END IF;
  END PROCESS intdelay_1_process;

  pipeAccMUXOut <= intdelay_reg_1(1);

  -- Normalize Accumulator Input
  multiplier_mul_temp <= reciprocalPiped * pipeAccMUXOut;
  recipMultOut <= multiplier_mul_temp(42 DOWNTO 11);

  -- Pipeline Output of Normalization
  outputPipeline_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      outputPipeline_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        outputPipeline_reg(0) <= recipMultOut;
        outputPipeline_reg(1) <= outputPipeline_reg(0);
      END IF;
    END IF;
  END PROCESS outputPipeline_process;

  Normalized_tmp <= outputPipeline_reg(1);

  Normalized <= std_logic_vector(Normalized_tmp);

END rtl;

